[{"content":"express와 역방향 프록시 기존 백엔드를 http 서버로 구성하고 서버에서 nginx를 통해 역방향 프록시를 구성하여 TLS를 구현하였다.\n앱 사전 예약 기능을 개발하면서 휴대전화 인증을 많이 요청하는 악의적인 사용자가 있을 것에 대비하여(이게 지금까지 대비되지 않았다는게 조금 충격적\u0026hellip;) express-rate-limit 라이브러리로 사용량을 제한하도록 했다.\n문제는 nginx에서 X-Forwarded-For 헤더까지 설정해주고 있는데도 불구하고 express가 항상 같은 아이피라고 인식하여서, 여러명의 사용자가 휴대전화 인증을 시도하면 제한된다는 것이었다.\n# nginx 설정 파일  server { location / { proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:3000; } # ... } 해결 방법은 실로 간단하다. 구태여 글로 쓸 필요도 없다고 느낄 정도다.\nconst app = express(); app.set(\u0026#34;trust proxy\u0026#34;, 1); // ...  app.listen(80); 왜 이런식으로 하는지 혼자서 생각해본 것인데, 검증되지 않은 어떤 프록시가 X-Forwarded-For 헤더에 다른 사람의 아이피를 넣을 가능성이 있기 때문에 검증된 프록시의 X-Forwarded-For 헤더만 신뢰하도록 한 것 같다. 근데 어차피 같은 네트워크인데 그냥 하면 안되는건가 싶다\u0026hellip;\n내가 정말 예상하지 못한 곳에서 취약점이나 버그가 발생할 수 있다는 걸 다시 깨달았다. 깨달은 순간엔 이미 늦은거 같기도 하다.\nECS 공부 ECS에 한번이라도 제대로 배포해보고 싶어서 하루종일 이거만 했는데 잘 안된다. 너무 고통스럽다. 대충 ECS, Service Discovery, Load Balancer등이 어떤식으로 동작하는지는 이해했는데 막상 올리면 배포가 안된다\u0026hellip;\n처음부터 다시 차근차근 해봐야겠다.\n","permalink":"https://goorm.me/devlog/3/","summary":"express와 역방향 프록시 기존 백엔드를 http 서버로 구성하고 서버에서 nginx를 통해 역방향 프록시를 구성하여 TLS를 구현하였다.\n앱 사전 예약 기능을 개발하면서 휴대전화 인증을 많이 요청하는 악의적인 사용자가 있을 것에 대비하여(이게 지금까지 대비되지 않았다는게 조금 충격적\u0026hellip;) express-rate-limit 라이브러리로 사용량을 제한하도록 했다.\n문제는 nginx에서 X-Forwarded-For 헤더까지 설정해주고 있는데도 불구하고 express가 항상 같은 아이피라고 인식하여서, 여러명의 사용자가 휴대전화 인증을 시도하면 제한된다는 것이었다.\n# nginx 설정 파일  server { location / { proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_pass http://127.","title":"개발일지#3"},{"content":"Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다\u0026hellip;\nECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.\n설정파일\ndatabase.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기\nConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .env 파일을 사용하도록 했다.  envFilePath: process.env.NODE_ENV === \u0026#34;development\u0026#34; ? \u0026#34;.env.development\u0026#34; : undefined, ignoreEnvFile: process.env.NODE_ENV !== \u0026#34;development\u0026#34;, // class-validator와 class-transformer로 별도의 인증 로직을 구현했다.  validate: validateConfig, }); TypeOrmModule.forRootAsync({ inject: [ConfigService], useFactory: async (config: ConfigService) =\u0026gt; { return { type: \u0026#34;postgres\u0026#34;, host: config.get(\u0026#34;database.host\u0026#34;), port: config.get(\u0026#34;database.port\u0026#34;), username: config.get(\u0026#34;database.username\u0026#34;), password: config.get(\u0026#34;database.password\u0026#34;), // ...  }; }, }); 그리고 생각보다 어려운 건 없는거 같다. VPC 구성에서 조금 해맸는데 이와 관련된 강의를 보니 이해가 잘 되는 것 같다.\n게임 서버 개발 게임 서버를 Node.js와 Websocket으로 구현했다. 여기까진 크게 어려운게 없는데, 유니티와 연결하기가 너무 귀찮고 복잡했다.\n유니티 WebGL에서 Websocket을 사용하기 위해서 NativeWebSocket 라이브러리를 사용했다. 그리고 서버와 클라이언트가 주고받는 메시지의 직렬화를 위해 JSON 라이브러리인 LitJson을 사용했다. LitJson이 특정 프로퍼티 등에 세세하게 접근할 수 있어 좋았다.\n// Message.cs  // JsonData 값을 Value로 사용할 수 없어서 직접 문자열을 포매팅하는 방식을 사용했다. public string ToJson() { return $\u0026#34;{{\\\u0026#34;type\\\u0026#34;:\\\u0026#34;{type}\\\u0026#34;,\\\u0026#34;data\\\u0026#34;:{data}}}\u0026#34;; } public static Message FromJson(string json) { var messageData = JsonMapper.ToObject(json); return new Message( messageData[\u0026#34;type\u0026#34;].ToString(), messageData.ContainsKey(\u0026#34;data\u0026#34;) ? messageData[\u0026#34;data\u0026#34;].ToJson() : null ); } public T DataAs\u0026lt;T\u0026gt;() { return JsonMapper.ToObject\u0026lt;T\u0026gt;(data); } 그리고 기존에 구현해둔 브라우저와의 통신에도 하나의 메서드만 이용하도록 했다. 코드가 너무 복잡하고 장황해진다는 이유이다.\n비동기 구현을 위해 C#의 이벤트 내지 구독 패턴을 사용했다.\n// Network.cs public class Network : MonoSingleton\u0026lt;Network\u0026gt; { private static WebSocket Socket { get; set; } private void Update() { #if !UNITY_WEBGL || UNITY_EDITOR  // 에디터에서는 이게 없으면 작동을 안하는 것 같다.  Socket?.DispatchMessageQueue(); #endif  } // 메시지를 구독하기 위한 이벤트이다.  // 대리자는 Message 클래스와 함께 구현이 되어 있고  // 브라우저와 통신하는 코드에서도 공용으로 쓰이고 있다.  public static event OnMessageDelegate OnMessageEvent = delegate { }; // 소켓을 통해 받은 메시지를 핸들링한다.  private static void Handler (byte[] bytes) { string json; // 올바른 UTF8 문자열이 아닐 경우에 무시하도록 했다.  try { json = Encoding.UTF8.GetString(bytes); } catch (ArgumentException) { return; } // JSON 문자열로부터 메시지를 생성하여 이벤트를 발생시킨다.  OnMessageEvent(Message.FromJson(json)); } // 웹 소켓에 연결하기 위한 반복자를 리턴하는 함수이다.  public static IEnumerator Connect() { var ws = new WebSocket(\u0026#34;ws://localhost:8080\u0026#34;); // 핸들러를 추가한다.  // ws.Connect 메서드 위에 있으면 작동을 안한다. (...)  ws.OnError += ErrorDialog.Fatal; ws.Handler += Handler ; // 연결을 시도하고 WaitUntil로 연결 될 때 까지 기다린다.  var connected = false; void OnOpen() { connected = true; } ws.OnOpen += OnOpen; ws.Connect(); yield return new WaitUntil(() =\u0026gt; connected); // 연결 완료 시 연결을 핸들링하는 핸드러를 이벤트에서 제거한다.  ws.OnOpen -= OnOpen; Socket = ws; } // 서버에 메시지를 전송한다.  public static void Send(Message message) { Socket.SendText(message.ToJson()); } // ... } 사용하는 쪽은 다음과 같이 사용한다.\npublic class Inventory : MonoBehaviour { private void Start() { // 이벤트를 구독한다.  Network.OnMessageEvent += Handler ; // 서버에 메시지를 전송한다.  Network.Send(new Messages.GetInventory()); } private void OnDestroy() { // 이벤트를 구독 해제한다.  Network.OnMessageEvent -= Handler ; } // 메시지를 핸들링하기 위한 메서드.  private void Handler (Message message) { // 메시지의 타입을 구분하여 사용한다.  if (message.type == GetInventoryResult.Type) { var data = message.DataAs\u0026lt;GetInventoryResult\u0026gt;(); // ...  } } } 글을 작성하면서 생각난 개선 사항들은 다음과 같다.\n  메시지의 각 타입에 대한 핸들러 목록을 구분하여(Dictionary 등으로) 구현하기. (속도 향상, 코드 중복 개선)\n  OnDestroy에서 매번 구독 해제를 해줘야하는 문제가 있는데, 이를 위한 별도의 핸들러 MonoBehaviour 클래스가 있으면 간단하게 할 수 있지 않을까싶다.\n  위 개선사항을 적용하여 사용하자면 코드는 다음과 같다.\npublic class Inventory : MonoBehaviour { private void Start() { // 제네릭을 통해 구현된다.  // C#에서 구현되는지는 모르겠지만 안되더라도 인자가 몇개 더 추가되는 수준이다.  Network.Handle\u0026lt;GetInventoryResult\u0026gt;(this, Handler); Network.Send(new Messages.GetInventory()); } private void Handler(GetInventoryResult data) { // ...  } }   ","permalink":"https://goorm.me/devlog/2/","summary":"Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다\u0026hellip;\nECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.\n설정파일\ndatabase.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기\nConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .","title":"개발일지#2"},{"content":"메일 정리하기 메일을 쉽게 정리하고 싶어서 찾아보니까 “보낸이로 묶어보기” 기능을 제공하는 메일 클라이언트가 별로 없더라.\n썬더버드를 우연히 깔아봤는데 mac에서 보기 나쁘지도 않고 위에 말한 기능을 제공해서 써봤는데 매우 좋다. 계속 쓸 거 같다.\n구 백엔드 수정  감사 카드 알림을 전송할때 Restaurant 인스턴스를 그대로 넣어버려서 “[object SequelizeInstance:Restaurant]” 처럼 나오는 문제가 있었다. 이런식의 실수를 조심해야겠다.  신규 백엔드 수정   IsNullable과 IsUndefinable 데코레이터를 구현해서 더 정확한 Validation이 가능해졌다.\n이 저장소의 이슈에서 코드를 갖고왔다. 데코레이터에 대해 조금 더 공부해보면 좋을듯.\nimport { ValidateIf, ValidationOptions } from \u0026#34;class-validator\u0026#34;; // Code from: https://github.com/mentatxx/class-validator-is-nullable/issues/3  export function IsNullable(options?: ValidationOptions): PropertyDecorator { return function IsNullableDecorator( prototype: Object, propertyKey: string | symbol ): void { ValidateIf((obj) =\u0026gt; obj[propertyKey] !== null, options)( prototype, propertyKey ); }; }   리뷰 수정 시 imageOrder 값을 지정하지 않은 것과 비어있는 것을 구분하게 하고 싶었는데, FormData에는 빈 배열이나 null 값을 필드로 사용할 수 없는 거 같아 JSON 문자열을 받도록 했다.\nclass-transformer를 이용하여 다음과 같이 문자열을 JSON으로 변환되도록 하였다. 놀랍게도 잘 작동한다!\nexport class UpdateReviewInputDto { // ...  @Type(() =\u0026gt; String) @IsUndefinable() @IsArray() @ArrayMinSize(0) @ArrayMaxSize(10) @IsString({ each: true }) @Length(44, 44, { each: true }) imageOrder?: string[]; }   위와 같이 IsNumber 등을 구현하면 Type(() ⇒ Number) 를 따로 붙여주지 않아도 될거같다. 아래와 같이 IsNumber를 새로 구현했다.\nimport { ValidationOptions } from \u0026#34;class-validator\u0026#34;; import { Type } from \u0026#34;class-transformer\u0026#34;; export function IsNumber(options?: ValidationOptions): PropertyDecorator { return function IsNumberDecorator( prototype: Object, propertyKey: string | symbol ): void { Type(() =\u0026gt; Number)(prototype, propertyKey); IsNumber(options)(prototype, propertyKey); }; }   ","permalink":"https://goorm.me/devlog/1/","summary":"메일 정리하기 메일을 쉽게 정리하고 싶어서 찾아보니까 “보낸이로 묶어보기” 기능을 제공하는 메일 클라이언트가 별로 없더라.\n썬더버드를 우연히 깔아봤는데 mac에서 보기 나쁘지도 않고 위에 말한 기능을 제공해서 써봤는데 매우 좋다. 계속 쓸 거 같다.\n구 백엔드 수정  감사 카드 알림을 전송할때 Restaurant 인스턴스를 그대로 넣어버려서 “[object SequelizeInstance:Restaurant]” 처럼 나오는 문제가 있었다. 이런식의 실수를 조심해야겠다.  신규 백엔드 수정   IsNullable과 IsUndefinable 데코레이터를 구현해서 더 정확한 Validation이 가능해졌다.\n이 저장소의 이슈에서 코드를 갖고왔다.","title":"개발일지#1"},{"content":"Hello, world!\n","permalink":"https://goorm.me/post/first/","summary":"Hello, world!","title":"Hello, world!"}]