<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>개발일지#2 | Goorm.me</title>
<meta name=keywords content>
<meta name=description content="개발일지 #2 Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다&mldr;
ECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.
설정파일
database.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기
ConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .">
<meta name=author content>
<link rel=canonical href=https://goorm.me/post/devlog-2/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://goorm.me/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://goorm.me/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://goorm.me/favicon-32x32.png>
<link rel=apple-touch-icon href=https://goorm.me/apple-touch-icon.png>
<link rel=mask-icon href=https://goorm.me/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="개발일지#2">
<meta property="og:description" content="개발일지 #2 Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다&mldr;
ECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.
설정파일
database.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기
ConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .">
<meta property="og:type" content="article">
<meta property="og:url" content="https://goorm.me/post/devlog-2/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-01-26T18:23:23+09:00">
<meta property="article:modified_time" content="2022-01-26T18:23:23+09:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="개발일지#2">
<meta name=twitter:description content="개발일지 #2 Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다&mldr;
ECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.
설정파일
database.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기
ConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://goorm.me/post/"},{"@type":"ListItem","position":3,"name":"개발일지#2","item":"https://goorm.me/post/devlog-2/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"개발일지#2","name":"개발일지#2","description":"개발일지 #2 Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다\u0026hellip;\nECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.\n설정파일\ndatabase.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기\nConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .","keywords":[],"articleBody":"개발일지 #2 Hugo로 일지 쓰기 Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다…\nECS 사용해보기 CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다. 이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.\n설정파일\ndatabase.host=localhost database.port=5432 database.name=root database.username=user database.password=password database.log=true database.sync=true jwt.secret=1234 Nest에서 사용하기\nConfigModule.forRoot({ isGlobal: true, // 개발 환경에서만 .env 파일을 사용하도록 했다.  envFilePath: process.env.NODE_ENV === \"development\" ? \".env.development\" : undefined, ignoreEnvFile: process.env.NODE_ENV !== \"development\", // class-validator와 class-transformer로 별도의 인증 로직을 구현했다.  validate: validateConfig, }); TypeOrmModule.forRootAsync({ inject: [ConfigService], useFactory: async (config: ConfigService) = { return { type: \"postgres\", host: config.get(\"database.host\"), port: config.get(\"database.port\"), username: config.get(\"database.username\"), password: config.get(\"database.password\"), // ...  }; }, }); 그리고 생각보다 어려운 건 없는거 같다. VPC 구성에서 조금 해맸는데 이와 관련된 강의를 보니 이해가 잘 되는 것 같다.\n게임 서버 개발 게임 서버를 Node.js와 Websocket으로 구현했다. 여기까진 크게 어려운게 없는데, 유니티와 연결하기가 너무 귀찮고 복잡했다.\n유니티 WebGL에서 Websocket을 사용하기 위해서 NativeWebSocket 라이브러리를 사용했다. 그리고 서버와 클라이언트가 주고받는 메시지의 직렬화를 위해 JSON 라이브러리인 LitJson을 사용했다. LitJson이 특정 프로퍼티 등에 세세하게 접근할 수 있어 좋았다.\n// Message.cs  // JsonData 값을 Value로 사용할 수 없어서 직접 문자열을 포매팅하는 방식을 사용했다. public string ToJson() { return $\"{{\\\"type\\\":\\\"{type}\\\",\\\"data\\\":{data}}}\"; } public static Message FromJson(string json) { var messageData = JsonMapper.ToObject(json); return new Message( messageData[\"type\"].ToString(), messageData.ContainsKey(\"data\") ? messageData[\"data\"].ToJson() : null ); } public T DataAs() { return JsonMapper.ToObject(data); } 그리고 기존에 구현해둔 브라우저와의 통신에도 하나의 메서드만 이용하도록 했다. 코드가 너무 복잡하고 장황해진다는 이유이다.\n비동기 구현을 위해 C#의 이벤트 내지 구독 패턴을 사용했다.\n// Network.cs public class Network : MonoSingleton { private static WebSocket Socket { get; set; } private void Update() { #if !UNITY_WEBGL || UNITY_EDITOR  // 에디터에서는 이게 없으면 작동을 안하는 것 같다.  Socket?.DispatchMessageQueue(); #endif  } // 메시지를 구독하기 위한 이벤트이다.  // 대리자는 Message 클래스와 함께 구현이 되어 있고  // 브라우저와 통신하는 코드에서도 공용으로 쓰이고 있다.  public static event OnMessageDelegate OnMessageEvent = delegate { }; // 소켓을 통해 받은 메시지를 핸들링한다.  private static void Handler (byte[] bytes) { string json; // 올바른 UTF8 문자열이 아닐 경우에 무시하도록 했다.  try { json = Encoding.UTF8.GetString(bytes); } catch (ArgumentException) { return; } // JSON 문자열로부터 메시지를 생성하여 이벤트를 발생시킨다.  OnMessageEvent(Message.FromJson(json)); } // 웹 소켓에 연결하기 위한 반복자를 리턴하는 함수이다.  public static IEnumerator Connect() { var ws = new WebSocket(\"ws://localhost:8080\"); // 핸들러를 추가한다.  // ws.Connect 메서드 위에 있으면 작동을 안한다. (...)  ws.OnError += ErrorDialog.Fatal; ws.Handler += Handler ; // 연결을 시도하고 WaitUntil로 연결 될 때 까지 기다린다.  var connected = false; void OnOpen() { connected = true; } ws.OnOpen += OnOpen; ws.Connect(); yield return new WaitUntil(() = connected); // 연결 완료 시 연결을 핸들링하는 핸드러를 이벤트에서 제거한다.  ws.OnOpen -= OnOpen; Socket = ws; } // 서버에 메시지를 전송한다.  public static void Send(Message message) { Socket.SendText(message.ToJson()); } // ... } 사용하는 쪽은 다음과 같이 사용한다.\npublic class Inventory : MonoBehaviour { private void Start() { // 이벤트를 구독한다.  Network.OnMessageEvent += Handler ; // 서버에 메시지를 전송한다.  Network.Send(new Messages.GetInventory()); } private void OnDestroy() { // 이벤트를 구독 해제한다.  Network.OnMessageEvent -= Handler ; } // 메시지를 핸들링하기 위한 메서드.  private void Handler (Message message) { // 메시지의 타입을 구분하여 사용한다.  if (message.type == GetInventoryResult.Type) { var data = message.DataAs(); // ...  } } } 글을 작성하면서 생각난 개선 사항들은 다음과 같다.\n  메시지의 각 타입에 대한 핸들러 목록을 구분하여(Dictionary 등으로) 구현하기. (속도 향상, 코드 중복 개선)\n  OnDestroy에서 매번 구독 해제를 해줘야하는 문제가 있는데, 이를 위한 별도의 핸들러 MonoBehaviour 클래스가 있으면 간단하게 할 수 있지 않을까싶다.\n  위 개선사항을 적용하여 사용하자면 코드는 다음과 같다.\npublic class Inventory : MonoBehaviour { private void Start() { // 제네릭을 통해 구현된다.  // C#에서 구현되는지는 모르겠지만 안되더라도 인자가 몇개 더 추가되는 수준이다.  Network.Handle(this, Handler); Network.Send(new Messages.GetInventory()); } private void Handler(GetInventoryResult data) { // ...  } }   ","wordCount":"621","inLanguage":"en","datePublished":"2022-01-26T18:23:23+09:00","dateModified":"2022-01-26T18:23:23+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://goorm.me/post/devlog-2/"},"publisher":{"@type":"Organization","name":"Goorm.me","logo":{"@type":"ImageObject","url":"https://goorm.me/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://goorm.me accesskey=h title="Goorm.me (Alt + H)">Goorm.me</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
개발일지#2
</h1>
<div class=post-meta><span title="2022-01-26 18:23:23 +0900 +0900">January 26, 2022</span>
</div>
</header>
<div class=post-content><h1 id=개발일지-2>개발일지 #2<a hidden class=anchor aria-hidden=true href=#개발일지-2>#</a></h1>
<h2 id=hugo로-일지-쓰기>Hugo로 일지 쓰기<a hidden class=anchor aria-hidden=true href=#hugo로-일지-쓰기>#</a></h2>
<p>Notion에 쓰려다가 Hugo로 쓰는게 좋을 것 같아 옮겼다. 테마도 이쁘고 좋다&mldr;</p>
<h2 id=ecs-사용해보기>ECS 사용해보기<a hidden class=anchor aria-hidden=true href=#ecs-사용해보기>#</a></h2>
<p>CodeBuild 등을 구성하다보니 그냥 파이프라인이 쓰고싶어져서 ECS로 배포하는 것까지 알아보았다.
이를 위해서 수정한건 설정을 toml 파일에서 환경변수로 옮긴 것이다. dotenv 파일도 다음과 같이 구성할 수 있고 class-transformer를 통해 올바른 자료형으로 변환되니 사용하는데에 불편한 것은 없을 것 같다.</p>
<p>설정파일</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>host</span>=<span style=color:#a6e22e>localhost</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>port</span>=<span style=color:#ae81ff>5432</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>name</span>=<span style=color:#a6e22e>root</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>username</span>=<span style=color:#a6e22e>user</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>password</span>=<span style=color:#a6e22e>password</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>log</span>=<span style=color:#66d9ef>true</span>
<span style=color:#a6e22e>database</span>.<span style=color:#a6e22e>sync</span>=<span style=color:#66d9ef>true</span>

<span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>secret</span>=<span style=color:#ae81ff>1234</span>
</code></pre></div><p>Nest에서 사용하기</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>ConfigModule</span>.<span style=color:#a6e22e>forRoot</span>({
  <span style=color:#a6e22e>isGlobal</span>: <span style=color:#66d9ef>true</span>,
  <span style=color:#75715e>// 개발 환경에서만 .env 파일을 사용하도록 했다.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>envFilePath</span>:
    <span style=color:#66d9ef>process.env.NODE_ENV</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;development&#34;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;.env.development&#34;</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>undefined</span>,
  <span style=color:#a6e22e>ignoreEnvFile</span>: <span style=color:#66d9ef>process.env.NODE_ENV</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#34;development&#34;</span>,
  <span style=color:#75715e>// class-validator와 class-transformer로 별도의 인증 로직을 구현했다.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>validate</span>: <span style=color:#66d9ef>validateConfig</span>,
});
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>TypeOrmModule</span>.<span style=color:#a6e22e>forRootAsync</span>({
  <span style=color:#a6e22e>inject</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>ConfigService</span>],
  <span style=color:#a6e22e>useFactory</span>: <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>config</span>: <span style=color:#66d9ef>ConfigService</span>) <span style=color:#f92672>=&gt;</span> {
    <span style=color:#66d9ef>return</span> {
      <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;postgres&#34;</span>,
      <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>config.get</span>(<span style=color:#e6db74>&#34;database.host&#34;</span>),
      <span style=color:#a6e22e>port</span>: <span style=color:#66d9ef>config.get</span>(<span style=color:#e6db74>&#34;database.port&#34;</span>),
      <span style=color:#a6e22e>username</span>: <span style=color:#66d9ef>config.get</span>(<span style=color:#e6db74>&#34;database.username&#34;</span>),
      <span style=color:#a6e22e>password</span>: <span style=color:#66d9ef>config.get</span>(<span style=color:#e6db74>&#34;database.password&#34;</span>),
      <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    };
  },
});
</code></pre></div><p>그리고 생각보다 어려운 건 없는거 같다. VPC 구성에서 조금 해맸는데 이와 관련된 강의를 보니 이해가 잘 되는 것 같다.</p>
<h2 id=게임-서버-개발>게임 서버 개발<a hidden class=anchor aria-hidden=true href=#게임-서버-개발>#</a></h2>
<p>게임 서버를 Node.js와 Websocket으로 구현했다. 여기까진 크게 어려운게 없는데, 유니티와 연결하기가 너무 귀찮고 복잡했다.</p>
<p>유니티 WebGL에서 Websocket을 사용하기 위해서 NativeWebSocket 라이브러리를 사용했다.
그리고 서버와 클라이언트가 주고받는 메시지의 직렬화를 위해 JSON 라이브러리인 LitJson을 사용했다.
LitJson이 특정 프로퍼티 등에 세세하게 접근할 수 있어 좋았다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Message.cs
</span><span style=color:#75715e></span>
<span style=color:#75715e>// JsonData 값을 Value로 사용할 수 없어서 직접 문자열을 포매팅하는 방식을 사용했다.
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ToJson()
{
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>$&#34;{{\&#34;</span>type<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#e6db74>&#34;:\&#34;{type}\&#34;,\&#34;data\&#34;:{data}}}&#34;</span>;
}

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Message FromJson(<span style=color:#66d9ef>string</span> json)
{
    <span style=color:#66d9ef>var</span> messageData = JsonMapper.ToObject(json);
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Message(
        messageData[<span style=color:#e6db74>&#34;type&#34;</span>].ToString(),
        messageData.ContainsKey(<span style=color:#e6db74>&#34;data&#34;</span>) ? messageData[<span style=color:#e6db74>&#34;data&#34;</span>].ToJson() : <span style=color:#66d9ef>null</span>
    );
}

<span style=color:#66d9ef>public</span> T DataAs&lt;T&gt;()
{
    <span style=color:#66d9ef>return</span> JsonMapper.ToObject&lt;T&gt;(data);
}
</code></pre></div><p>그리고 기존에 구현해둔 브라우저와의 통신에도 하나의 메서드만 이용하도록 했다.
코드가 너무 복잡하고 장황해진다는 이유이다.</p>
<p>비동기 구현을 위해 C#의 이벤트 내지 구독 패턴을 사용했다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Network.cs
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Network</span> : MonoSingleton&lt;Network&gt;
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> WebSocket Socket { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
    {
<span style=color:#75715e>#if !UNITY_WEBGL || UNITY_EDITOR
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 에디터에서는 이게 없으면 작동을 안하는 것 같다.
</span><span style=color:#75715e></span>        Socket?.DispatchMessageQueue();
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }

    <span style=color:#75715e>// 메시지를 구독하기 위한 이벤트이다.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 대리자는 Message 클래스와 함께 구현이 되어 있고
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 브라우저와 통신하는 코드에서도 공용으로 쓰이고 있다.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>event</span> OnMessageDelegate OnMessageEvent = <span style=color:#66d9ef>delegate</span> { };

    <span style=color:#75715e>// 소켓을 통해 받은 메시지를 핸들링한다.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Handler
    (<span style=color:#66d9ef>byte</span>[] bytes)
    {
        <span style=color:#66d9ef>string</span> json;

        <span style=color:#75715e>// 올바른 UTF8 문자열이 아닐 경우에 무시하도록 했다.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>try</span>
        {
            json = Encoding.UTF8.GetString(bytes);
        }
        <span style=color:#66d9ef>catch</span> (ArgumentException)
        {
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#75715e>// JSON 문자열로부터 메시지를 생성하여 이벤트를 발생시킨다.
</span><span style=color:#75715e></span>        OnMessageEvent(Message.FromJson(json));
    }

    <span style=color:#75715e>// 웹 소켓에 연결하기 위한 반복자를 리턴하는 함수이다.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IEnumerator Connect()
    {
        <span style=color:#66d9ef>var</span> ws = <span style=color:#66d9ef>new</span> WebSocket(<span style=color:#e6db74>&#34;ws://localhost:8080&#34;</span>);

        <span style=color:#75715e>// 핸들러를 추가한다.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// ws.Connect 메서드 위에 있으면 작동을 안한다. (...)
</span><span style=color:#75715e></span>        ws.OnError += ErrorDialog.Fatal;
        ws.Handler
         += Handler
        ;

        <span style=color:#75715e>// 연결을 시도하고 WaitUntil로 연결 될 때 까지 기다린다.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> connected = <span style=color:#66d9ef>false</span>;

        <span style=color:#66d9ef>void</span> OnOpen()
        {
            connected = <span style=color:#66d9ef>true</span>;
        }

        ws.OnOpen += OnOpen;
        ws.Connect();
        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitUntil(() =&gt; connected);

        <span style=color:#75715e>// 연결 완료 시 연결을 핸들링하는 핸드러를 이벤트에서 제거한다.
</span><span style=color:#75715e></span>        ws.OnOpen -= OnOpen;

        Socket = ws;
    }

    <span style=color:#75715e>// 서버에 메시지를 전송한다.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Send(Message message)
    {
        Socket.SendText(message.ToJson());
    }

    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>사용하는 쪽은 다음과 같이 사용한다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inventory</span> : MonoBehaviour {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start() {
        <span style=color:#75715e>// 이벤트를 구독한다.
</span><span style=color:#75715e></span>        Network.OnMessageEvent += Handler
        ;
        <span style=color:#75715e>// 서버에 메시지를 전송한다.
</span><span style=color:#75715e></span>        Network.Send(<span style=color:#66d9ef>new</span> Messages.GetInventory());
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy() {
        <span style=color:#75715e>// 이벤트를 구독 해제한다.
</span><span style=color:#75715e></span>        Network.OnMessageEvent -= Handler
        ;
    }

    <span style=color:#75715e>// 메시지를 핸들링하기 위한 메서드.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Handler
    (Message message) {
        <span style=color:#75715e>// 메시지의 타입을 구분하여 사용한다.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (message.type == GetInventoryResult.Type) {
            <span style=color:#66d9ef>var</span> data = message.DataAs&lt;GetInventoryResult&gt;();
            <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>        }
    }
}
</code></pre></div><p>글을 작성하면서 생각난 개선 사항들은 다음과 같다.</p>
<ul>
<li>
<p>메시지의 각 타입에 대한 핸들러 목록을 구분하여(Dictionary 등으로) 구현하기. (속도 향상, 코드 중복 개선)</p>
</li>
<li>
<p>OnDestroy에서 매번 구독 해제를 해줘야하는 문제가 있는데, 이를 위한 별도의 핸들러 MonoBehaviour 클래스가 있으면 간단하게 할 수 있지 않을까싶다.</p>
</li>
<li>
<p>위 개선사항을 적용하여 사용하자면 코드는 다음과 같다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inventory</span> : MonoBehaviour {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start() {
        <span style=color:#75715e>// 제네릭을 통해 구현된다.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// C#에서 구현되는지는 모르겠지만 안되더라도 인자가 몇개 더 추가되는 수준이다.
</span><span style=color:#75715e></span>        Network.Handle&lt;GetInventoryResult&gt;(<span style=color:#66d9ef>this</span>, Handler);
        Network.Send(<span style=color:#66d9ef>new</span> Messages.GetInventory());
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Handler(GetInventoryResult data) {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }
}
</code></pre></div></li>
</ul>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://goorm.me>Goorm.me</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>